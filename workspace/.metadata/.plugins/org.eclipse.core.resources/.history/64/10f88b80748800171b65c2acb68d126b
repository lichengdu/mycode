package com.lcd.util;

import java.util.Map;

import com.alibaba.fastjson.JSONObject;
import com.lcd.exception.MgException;


public class MethodArgsUtil
{
	/**
	 * 检查方法名称、服务名称、参数数据，并返回对象
	 * @author 黄永丰
	 * @createtime 2016年1月2日
	 * @param postdata 传入数据
	 * @return 方法名称、服务名称、参数数据对象
	 */
	public static MethodArgs checkPostMethodData(Map<String,String> postdata) throws Exception
	{
		MethodArgs methodArgs = new MethodArgs();
		try
		{
			//1、获取传入参数
			String src_appid = postdata.containsKey("appid") ? postdata.get("appid") : "";
			String method = postdata.containsKey("method") ? postdata.get("method") : "";
			String format = postdata.containsKey("format") ? postdata.get("format") : "";
			String data = postdata.containsKey("data") ? postdata.get("data") : "";
			String v = postdata.containsKey("v") ? postdata.get("v") : "";
			String timestamp = postdata.containsKey("timestamp") ? postdata.get("timestamp") : "";
			String sign = postdata.containsKey("sign") ? postdata.get("sign") : "";
			String sessionid = postdata.containsKey("session") ? postdata.get("session") : "";
			String target_appid = postdata.containsKey("target_appid") ? postdata.get("target_appid") : "";
			// 打印调用接口时加密数据
//			ILogUtil.requestEncryptData(JSONObject.toJSONString(postdata), method);
			
			//2、判断method
			checkInterfaceName(method);
			
			//3、验证接口,如果是config服务就不用session,全是base64加密,其它的获取session,并解密数据
			String serviceName = getServiceName(method);
			String secretkey = null;
			String methodData = null;
			if ("config".equals(serviceName)) 
				methodData = Base64Method.DecryptBase64(data);
			else
			{
				//3.1、验证接口是否存在redis里
				Map<String, Object> apiMap = getInterfaceNameByRedis(method);
				int dbencryptflag = ObjectParser.toInteger(apiMap.get("encryptflag"));// 0.加密 1.不加密
				//3.2、根据session解密数据
				if (dbencryptflag == 0) 
				{
					if (sessionid == null || "".equals(sessionid))
					{
						// 不需要session
						Map<String, Object> configParam = ConfigApiUtil.getSystemconfigParam();
						//现要核心已修改是传入当前登录的公司、所以不能判断appid、但密钥还是用平台分配的appid密钥
//						String appid = ObjectParser.toString(configParam.get("subsystemid"));
//						if (!appid.equals(src_appid)) throw new MgException(-1, "传入src_appid与平台分配不一至.");
						secretkey = ObjectParser.toString(configParam.get("secretkey"));
					}
					else
					{
						//检查session
						MgSession mgSession = checkMgSession(sessionid);
						//验证签名
						secretkey = mgSession.getSecretkey();
						src_appid = ObjectParser.toString(mgSession.getCompanyid());
						String md5sign = MD5Util.string2MD5(secretkey + src_appid+ data + format + method + sessionid + target_appid+ timestamp + v + secretkey);
						if (!md5sign.equals(sign))
							throw new MgException(-1, "签名不正确.");
					}
					//解密数据
					methodData = AesEncryption.Desencrypt(data, secretkey, secretkey).trim();
				}
				//3.3、如果是不加密就直接base64解密
				else
					methodData = Base64Method.DecryptBase64(data);
			}
//			ILogUtil.info("调用接口解密数据:"+methodData);
			//4、对应参数返回
			String className = getClassName(method);//获取对应的类型和方法名称
			String methodName = getMethodName(method);
			methodArgs.setMethodData(methodData);
			methodArgs.setMethodName(methodName);
			methodArgs.setClassName(className);
			methodArgs.setInterfaceName(method);
			return methodArgs;
		}
		catch (MgException ex)
		{
			throw new MgException(ex.getRet(), ex.getMessage());
		}
		catch (Exception e)
		{
			if (e.getClass().equals(MgException.class)) throw e;
			else throw new MgException(-1, "检查方法名称、服务名称、参数数据失败."+e.getMessage(),e);
		}
	}
	
	/**
	 * redis里获取api接口信息
	 * @author 黄永丰
	 * @createtime 2016年10月8日
	 * @param interfaceName 接口名称
	 * @return 返回接口信息
	 * @throws Exception
	 */
	@SuppressWarnings("unchecked")
	public static Map<String, Object> getInterfaceNameByRedis(String interfaceName) throws Exception
	{
		JSONObject jskey = new JSONObject();
		String pkey = EmRedisKeyPrefix.API.getValue() + interfaceName;
		jskey.put("primaryKey", pkey);
		String method = ApiNameUtil.CONFIG_GET_REDIS;
		String apiData = DubboCallApiUtil.doPostForOtherSystem(method,jskey.toJSONString());
		if (apiData == null || apiData.isEmpty())
			throw new MgException(-1, "找不到接口为" + interfaceName + "的数据.","redis找不到接口为" + pkey + "的数据.");
		Map<String, Object> apidataMap = CheckJSONDataUtil.checkJSONData(apiData);
		Integer ret = ObjectParser.toInteger(apidataMap.get("ret"));
		if (ret == null || ret != 0) 
			throw new MgException(-1, "找不到接口为" + interfaceName + "的数据.","redis找不到接口为" + pkey + "的数据.");
		Map<String, Object> apiMap = (Map<String, Object>) apidataMap.get("data");
		if (apiMap == null) 
			throw new MgException(-1, "找不到接口为" + interfaceName + "的数据.","redis找不到接口为" + pkey + "的数据.");
		return apiMap;
	}
	
	/**
	 * 验证session
	 * @author 黄永丰
	 * @createtime 2016年10月8日
	 * @param interfaceName 接口名称
	 * @return 返回接口信息
	 * @throws Exception
	 */
	public static MgSession checkMgSession(String sessionid) throws Exception
	{
		MgSession redisMgSession = null;
		//获取tokenMgSession
		String result = ConfigApiUtil.getServiceToken();
		MgSession tokenMgSession = JSONObject.parseObject(result, MgSession.class);
		// 从redis里检查session
		if (tokenMgSession.getSessionid().equals(sessionid)) 
			redisMgSession = tokenMgSession;
		else
		{
			// 登陆session,需要重置有效时间
			redisMgSession = MgSessionManager.getInstance().getMgSession(sessionid);
			if (redisMgSession != null && redisMgSession.getDevicetype() != EmDevicetype.DEVICETYPE_4.getValue())
				MgSessionManager.getInstance().setSession(sessionid, redisMgSession, MgSessionManager.sessionTime);
		}
		if (redisMgSession == null) 
			throw new MgException(10,"session已过期,请重新登录.","redis里找不到session为[" + sessionid + "]数据.");
		return redisMgSession;
	}
	

	/**
	 * 判断调用接口类的方法名称
	 * @author 黄永丰
	 * @createtime 2016年1月3日
	 * @param interfaceName 接口名称
	 * @return 返回调用接口类的方法名称
	 */
	public static void checkInterfaceName(String interfaceName)
	{
		if (interfaceName == null || interfaceName.length() == 0)
			throw new MgException(-1, "method参数不能为空.");
		String[] methodToken = interfaceName.split("\\.");
		if (methodToken.length < 4)
			throw new MgException(-1, "传入method方法长度必须大于4节.");
	}
	
	/**
	 * 获取调用接口的服务名称
	 * @author 黄永丰
	 * @createtime 2016年1月3日
	 * @param interfaceName 接口名称
	 * @return 返回用接口的服务名称
	 */
	public static String getServiceName(String interfaceName)
	{
		String serviceName = "";
		String[] methodToken = interfaceName.split("\\.");
		serviceName = methodToken[1].toLowerCase();
		return serviceName;
	}
	
	/**
	 * 获取调用接口类的方法名称
	 * @author 黄永丰
	 * @createtime 2016年1月3日
	 * @param interfaceName 接口名称
	 * @return 返回调用接口类的方法名称
	 */
	public static String getMethodName(String interfaceName)
	{
		String methodName = "";
		String[] methodToken = interfaceName.split("\\.");
		int count = 0;
		for (int i = methodToken.length - 1; i >= 3; i--)
		{
			if (count == 0)
				methodName += methodToken[i].toLowerCase();
			else
				methodName += methodToken[i].substring(0, 1).toUpperCase() + methodToken[i].substring(1);
			count++;
		}
		return methodName;
	}

	/**
	 * 获取调用接口的类名称
	 * @author 黄永丰
	 * @createtime 2016年1月3日
	 * @param interfaceName 接口名称
	 * @return 返回用接口的类名称
	 */
	public static String getClassName(String interfaceName)
	{
		String className = "";
		String[] methodToken = interfaceName.split("\\.");
		className = methodToken[2].toLowerCase() + "ServiceImpl";
		return className;
	}

	public static void main(String[] args)
	{
		System.out.println(getClassName("maplemart.openapi.test.get"));
		System.out.println(getMethodName("maplemart.openapi.test.get"));
		System.out.println(getClassName("maplemart.openapi.test.all.get"));
		System.out.println(getMethodName("maplemart.openapi.test.all.get"));
	}

}
